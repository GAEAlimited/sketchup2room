#include "StdAfx.h"
#include "ModelWriter.h"
#include "SketchupHelper.h"



ModelWriter::ModelWriter(const string& dir, const string& name)
{
	m_OutputDir = dir;

	m_ObjFile.open(m_OutputDir + name + ".obj");
	m_ObjFile << "# File generated by sketchup2room" << endl;
	m_ObjFile << "mtllib " << name << ".mtl" << endl;
	m_ObjFile.precision(3);
	m_ObjFile.setf( std::ios::fixed, std:: ios::floatfield );

	m_Faces.precision(3);
	m_Faces.setf( std::ios::fixed, std:: ios::floatfield );

	m_MtlFile.open(m_OutputDir + name + ".mtl");
	m_MtlFile << "# File generated by sketchup2room" << endl;

}


ModelWriter::~ModelWriter(void)
{
}


void ModelWriter::visitFaces(SUEntitiesRef ents, VisitorFunc func, bool recursive, Transform transform)
{
	size_t count =0;
	SUEntitiesGetNumFaces(ents,&count);

	vector<SUFaceRef> faces(count);
	SUEntitiesGetFaces(ents,count,faces.data(),&count);

	for(int i=0; i < count; i++){
		(*this.*func)(faces[i], transform);
	}

	SUEntitiesGetNumGroups(ents,&count);
	vector<SUGroupRef> groups(count);
	SUEntitiesGetGroups(ents,count,groups.data(),&count);


	for(int i=0; i < count; i++){
		SUEntitiesRef ents2 = SU_INVALID;
		SUGroupGetEntities(groups[i],&ents2);

		Transform t;
		SUGroupGetTransform(groups[i], (SUTransformation*)&t);
		visitFaces(ents2,func,true, transform * t);
	}

	if(recursive) {
		
		SUEntitiesGetNumInstances(ents,&count);
		vector<SUComponentInstanceRef> instances(count);
		SUEntitiesGetInstances(ents,count,instances.data(),&count);
	
		for(int i=0; i < count; i++){
			
			Transform t;
			SUComponentDefinitionRef def = SU_INVALID;
			SUEntitiesRef ents2 = SU_INVALID;

			SUComponentInstanceGetTransform(instances[i],(SUTransformation*)&t);
			SUComponentInstanceGetDefinition(instances[i],&def);
			SUComponentDefinitionGetEntities(def,&ents2);

			visitFaces(ents2,func,true, transform * t);
		}
	}
}

void ModelWriter::write(SUEntitiesRef ents, bool recursive)
{
	cout << " - Gathering materials" << endl;
	visitFaces(ents, &ModelWriter::gatherMaterials, recursive);
	
	/*
	cout << " - Generating meshes" << endl;
	visitFaces(ents, &ModelWriter::makeHelper, recursive);
	
	cout << " - Writing Vertex data" << endl;
	visitFaces(ents, &ModelWriter::writeVertices, recursive);

	cout << " - Writing Faces" << endl;
	m_VerticesUsed = 1;
	m_TexCoordsUsed = 2;
	visitFaces(ents, &ModelWriter::writeFaces, recursive);
	*/

	for(map<string,SUMaterialRef>::iterator itr = m_Materials.begin(); itr != m_Materials.end(); itr++) {
		cout << " - Writing faces of " << itr->first << endl;

		m_CurrentMat = itr->first;
		m_Faces << "usemtl " << itr->first << endl;
		visitFaces(ents, &ModelWriter::writeFaces, recursive);
	}

	for(size_t i = 0; i < m_UniquePositions.size(); i++) 
		m_ObjFile << "v " << m_UniquePositions[i] / g_Scale << endl;

	for(size_t i = 0; i < m_UniqueNormals.size(); i++) 
		m_ObjFile << "vn " << m_UniqueNormals[i] / g_Scale << endl;

	for(size_t i = 0; i < m_UniqueTextures.size(); i++) 
		m_ObjFile << "vt " << m_UniqueTextures[i].x << " " << m_UniqueTextures[i].y << endl;


	m_ObjFile << m_Faces.str();
	
	cout << " - Writing Materials" << endl;
	for(map<string,SUMaterialRef>::iterator itr = m_Materials.begin(); itr != m_Materials.end(); itr++){
		SUMaterialRef mat = itr->second;
		m_MtlFile << "newmtl " <<  itr->first << endl;
		
		m_MtlFile << "illium 4" << endl;

		SUColor ambient = {0};
		m_MtlFile << "Ka " << (ambient.red / 255.0f) << " " << (ambient.green/255.0f) << " " << (ambient.blue/255.0f) << endl; 
		
		SUColor diffuse;
		SUMaterialGetColor(mat,&diffuse);
		m_MtlFile << "Kd " << (diffuse.red / 255.0f) << " " << (diffuse.green/255.0f) << " " << (diffuse.blue/255.0f) << endl; 
		
		if(ambient.alpha != 1.0) {
			m_MtlFile << "d " << (ambient.alpha / 255.0f) << endl;
			m_MtlFile << "Tr " << (ambient.alpha / 255.0f) << endl;
		}

		SUTextureRef tex = SU_INVALID;
		if(SUMaterialGetTexture(mat,&tex) == SU_ERROR_NONE) {
			SUStringRef fileName = SU_INVALID;
			SUStringCreate(&fileName);
			if(SUTextureGetFileName(tex,&fileName) == SU_ERROR_NONE) {
				string f = SketchupHelper::fromSUString(fileName);

				for(int i=0; i < f.length(); i ++){
					if(f[i] == ' ') f[i] = '_';
				}

				SUTextureWriteToFile(tex,(m_OutputDir+f).c_str());

				m_MtlFile << "Tf 1.00 1.00 1.00" << endl;
				//mtlFile << "map_Ka " << f << endl;
				m_MtlFile << "map_Kd " << f << endl;

				m_MtlFile << "Ni 1.00" << endl;
				m_MtlFile << "Ks 1.00 1.00 1.00" << endl;
				m_MtlFile << "Ns 0.00" << endl;
			}
		} 
	}
	
}

bool ModelWriter::shouldWriteBackFace(SUFaceRef face) {
	string name = SketchupHelper::getBackFaceMaterialName(face);
	if(name == "" || name == "$nodraw") {
		return false;
	}
	return true;
}

bool ModelWriter::shouldWriteFrontFace(SUFaceRef face) {
	string name = SketchupHelper::getFrontFaceMaterialName(face);
	if(name == "" || name == "$nodraw") {
		return false;
	}
	return true;
}



void ModelWriter::gatherMaterials(SUFaceRef face, const Transform&){

	SUMaterialRef mat = SU_INVALID;
	
	if(shouldWriteFrontFace(face)) {
		SUFaceGetFrontMaterial(face, &mat);
		m_Materials[SketchupHelper::materialName(mat)] = mat;
	}

	if(shouldWriteBackFace(face)) {
		SUFaceGetBackMaterial(face, &mat);
		m_Materials[SketchupHelper::materialName(mat)] = mat;
	}
}


void ModelWriter::writeFace(SUMeshHelperRef mesh, const Transform& transform, bool front, bool textured) {

	size_t vertexCount=0;
	SUMeshHelperGetNumVertices(mesh,&vertexCount);
	vector<SUPoint3D> verts(vertexCount);
	SUMeshHelperGetVertices(mesh,vertexCount,verts.data(),&vertexCount);

	vector<SUVector3D> normals(vertexCount);
	SUMeshHelperGetNormals(mesh,vertexCount,normals.data(),&vertexCount);

	vector<SUPoint3D> textures(vertexCount);
	
	size_t triCount = 0;
	SUMeshHelperGetNumTriangles(mesh,&triCount);

	size_t gotIndices = 0;
	vector<size_t> indicies(triCount*3);
	SUResult res = SUMeshHelperGetVertexIndices(mesh,triCount*3,indicies.data(),&gotIndices);
	assert(res == SU_ERROR_NONE);

	SUPoint3D fakePoint = { 9999.0, 9999.0, 9999.0 };
	size_t iFakePoint = getIndexedTex(fakePoint);

	if(textured) {
		if(front) {
			SUMeshHelperGetFrontSTQCoords(mesh,vertexCount,textures.data(),&vertexCount);
		} else {
			SUMeshHelperGetBackSTQCoords(mesh,vertexCount,textures.data(),&vertexCount);
		}
	}
	float normalScale = 1.0f;
	if(!front) {
		normalScale = -1.0f;
	}
	
	bool flip = !front;

	SUVector3D xFlipTest = xaxis * transform;
	if(xFlipTest.x < 0) {
		flip = !flip;
	}

	SUVector3D yFlipTest = yaxis * transform;
	if(yFlipTest.y < 0) {
		flip = !flip;
	}
	
	for(size_t t = 0; t < triCount; t++) {
			
		m_Faces << "f ";

		for(int i=0; i<3; i++) {

			int j = (t*3) + (flip ? 2-i : i);
			
			m_Faces << getIndexedPos(verts[indicies[j]]*transform);

			if(textured) {
				m_Faces << "/" << getIndexedTex(textures[indicies[j]]);
			}else {
				 m_Faces << "/" << iFakePoint;
			}

			m_Faces << "/" <<  getIndexedNormal(normals[indicies[j]]*normalScale*transform) << " ";
		}

		m_Faces << endl;
	}

}

void ModelWriter::writeFaces(SUFaceRef face, const Transform& t){

	SUMeshHelperRef mesh = SU_INVALID;
	SUMeshHelperCreate(&mesh,face);

	if(SketchupHelper::getFrontFaceMaterialName(face) == m_CurrentMat) {
		writeFace(mesh, t, true, SketchupHelper::isFrontFaceTextured(face));
	}

	if(SketchupHelper::getBackFaceMaterialName(face) == m_CurrentMat) {
		writeFace(mesh, t, false, SketchupHelper::isBackFaceTextured(face));
	}
	
}

/*
void ModelWriter::makeHelper(SUFaceRef face, const Transform&){

	SUMeshHelperRef helper = SU_INVALID;
	SUMeshHelperCreate(&helper,face);
	m_MeshHelpers[face.ptr] = helper;
}
*/

/*
void ModelWriter::writeVertices(SUFaceRef face, const Transform& t){
	SUMeshHelperRef helper = m_MeshHelpers[face.ptr];

	//m_ObjFile << "# Verts for Face " << face.ptr << endl;

	size_t vertexCount = 0;
	SUMeshHelperGetNumVertices(helper,&vertexCount);
	
	vector<SUPoint3D> verts(vertexCount);
	vector<SUVector3D> normals(vertexCount);
	vector<SUPoint3D> tcs(vertexCount);

	SUMeshHelperGetVertices(helper,vertexCount,&verts[0],&vertexCount);
	SUMeshHelperGetNormals(helper,vertexCount,&normals[0],&vertexCount);

	if(shouldWriteFrontFace(face)) {

		bool textured = SketchupHelper::isFrontFaceTextured(face);

		if(textured) SUMeshHelperGetFrontSTQCoords(helper,vertexCount,&tcs[0],&vertexCount);

		for(size_t j=0; j < vertexCount; j++) {
			m_ObjFile << "v " << (verts[j] * t) / g_Scale << endl;
			
			if(textured) m_ObjFile << "vt " << tcs[j].x << " " << tcs[j].y << endl;
			m_ObjFile << "vn " << normals[j] * t << endl;
		}
	}

	if(shouldWriteBackFace(face)) {
		bool textured = SketchupHelper::isBackFaceTextured(face);
		if(textured) SUMeshHelperGetBackSTQCoords(helper,vertexCount,&tcs[0],&vertexCount);
		for(size_t j=0; j < vertexCount; j++) {
			m_ObjFile << "v " << (verts[j] * t) / g_Scale << endl;
			if(textured) m_ObjFile << "vt " << tcs[j].x << " " << tcs[j].y << endl;
			m_ObjFile << "vn " << normals[j] * -1.0f  * t << endl;
		}
	}
}

void ModelWriter::writeFaces(SUFaceRef face, const Transform&){
	SUMeshHelperRef mesh = m_MeshHelpers[face.ptr];

	size_t vertexCount=0;
	SUMeshHelperGetNumVertices(mesh,&vertexCount);

	size_t triCount = 0;
	SUMeshHelperGetNumTriangles(mesh,&triCount);

	size_t gotIndices = 0;
	vector<size_t> indicies(triCount*3);
	SUResult res = SUMeshHelperGetVertexIndices(mesh,triCount*3,indicies.data(),&gotIndices);
	assert(res == SU_ERROR_NONE);
		
	
	if(shouldWriteFrontFace(face)) {
	
	//	m_ObjFile << "# Front  Face " << face.ptr << endl;
		
		string mat = SketchupHelper::getFrontFaceMaterialName(face);
		if(mat != m_CurrentMat){
			m_CurrentMat = mat;
			m_ObjFile << "usemtl " << mat << endl;
		}
		size_t s = m_VerticesUsed;
		
		if(SketchupHelper::isFrontFaceTextured(face)) {
			size_t t = m_TexCoordsUsed;
			for(size_t j=0; j < triCount; j++) {
				m_ObjFile << "f ";
				m_ObjFile << (s + indicies[(j*3)+0]) << "/" << (t + indicies[(j*3)+0]) << "/" << (s + indicies[(j*3)+0])<< " ";
				m_ObjFile << (s + indicies[(j*3)+1]) << "/" << (t + indicies[(j*3)+1]) << "/" << (s + indicies[(j*3)+1]) << " ";
				m_ObjFile << (s + indicies[(j*3)+2]) << "/" << (t + indicies[(j*3)+2]) << "/" << (s + indicies[(j*3)+2]) << endl;
			}
			m_TexCoordsUsed += vertexCount;
		}else {
			for(size_t j=0; j < triCount; j++) {
		
				m_ObjFile << "f ";
				m_ObjFile << (s + indicies[(j*3)+0]) << "/1/" << (s + indicies[(j*3)+0])<< " ";
				m_ObjFile << (s + indicies[(j*3)+1]) << "/1/" << (s + indicies[(j*3)+1]) << " ";
				m_ObjFile << (s + indicies[(j*3)+2]) << "/1/" << (s + indicies[(j*3)+2]) << endl;
			}	
		}
			
		m_VerticesUsed += vertexCount;
	}

	if(shouldWriteBackFace(face)) {
	
		m_ObjFile << "# Back Face " << face.ptr << endl;
		m_ObjFile << "usemtl " << SketchupHelper::getBackFaceMaterialName(face) << endl;

		size_t s = m_VerticesUsed;
		
		if(SketchupHelper::isBackFaceTextured(face)) {
			size_t t = m_TexCoordsUsed;
			for(size_t j=0; j < triCount; j++) {
				m_ObjFile << "f ";
				m_ObjFile << (s + indicies[(j*3)+0]) << "/" << (t + indicies[(j*3)+0]) << "/" << (s + indicies[(j*3)+0]) << " ";
				m_ObjFile << (s + indicies[(j*3)+1]) << "/" << (t + indicies[(j*3)+1]) << "/" << (s + indicies[(j*3)+1]) << " ";
				m_ObjFile << (s + indicies[(j*3)+2]) << "/" << (t + indicies[(j*3)+2]) << "/" << (s + indicies[(j*3)+2]) << endl;
			}
			m_TexCoordsUsed += vertexCount;
		} else {
			for(size_t j=0; j < triCount; j++) {
				m_ObjFile << "f ";
				m_ObjFile << (s + indicies[(j*3)+0]) << "/1/" << (s + indicies[(j*3)+0]) << " ";
				m_ObjFile << (s + indicies[(j*3)+1]) << "/1/" << (s + indicies[(j*3)+1]) << " ";
				m_ObjFile << (s + indicies[(j*3)+2]) << "/1/" << (s + indicies[(j*3)+2]) << endl;
			}
		}
		
		m_VerticesUsed += vertexCount;
	}
}
*/

string ModelWriter::getMaterialFile(const string& objFile) {

	ifstream file(objFile);

	if(!file.good()) {
		cerr << "Error examining file " << objFile;
		exit(1);
	}

	char buffer[400];
	while(!file.eof()) {

		file.getline(buffer,sizeof(buffer));

		if(strncmp(buffer,"mtllib",6) == 0){
			string file = buffer+7;
			if(file[0] == '.' && file[1] == '/')
				file = file.substr(2);

			return dirName(objFile) + file;
		}
	}

	return "";
}

set<string> ModelWriter::getTextures(const string& mtlFile) {

	set<string> ret;
	ifstream file(mtlFile);


	char buffer[300];
	while(!file.eof()) {

		file.getline(buffer,sizeof(buffer));

		if(strncmp(buffer,"map_Kd",6) == 0){
			string file = buffer+7;
			if(file[0] == '.' && file[1] == '/')
				file = file.substr(2);

			ret.insert(dirName(mtlFile) + file);
		}
	}

	return ret;
}