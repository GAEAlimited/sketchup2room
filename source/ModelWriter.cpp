#include "StdAfx.h"
#include "ModelWriter.h"
#include "SketchupHelper.h"

bool fileExists(const string& file)
{
   WIN32_FIND_DATAA FindFileData;
   HANDLE handle = FindFirstFileA(file.c_str(), &FindFileData) ;
   int found = handle != INVALID_HANDLE_VALUE;
   if(found) 
   {
       FindClose(handle);
	   return true;
   }
   return false;
}

ModelWriter::ModelWriter(const string& dir, const string& name)
{
	m_OutputDir = dir;

	m_ObjFile.open(m_OutputDir + name + ".obj");
	m_ObjFile << "# File generated by sketchup2room" << endl;
	m_ObjFile << "vt 9999 9999" << endl;
	m_ObjFile.precision(3);
	m_ObjFile.setf( std::ios::fixed, std:: ios::floatfield );

	m_MtlFile.open(m_OutputDir + name + ".mtl");
	m_MtlFile << "# File generated by sketchup2room" << endl;

}


ModelWriter::~ModelWriter(void)
{
}


void ModelWriter::visitFaces(SUEntitiesRef ents, VisitorFunc func, bool recursive, Transform transform)
{
	size_t count =0;
	SUEntitiesGetNumFaces(ents,&count);

	vector<SUFaceRef> faces(count);
	SUEntitiesGetFaces(ents,count,faces.data(),&count);

	for(int i=0; i < count; i++){
		(*this.*func)(faces[i], transform);
	}

	SUEntitiesGetNumGroups(ents,&count);
	vector<SUGroupRef> groups(count);
	SUEntitiesGetGroups(ents,count,groups.data(),&count);


	for(int i=0; i < count; i++){
		SUEntitiesRef ents2 = SU_INVALID;
		SUGroupGetEntities(groups[i],&ents2);

		Transform t;
		SUGroupGetTransform(groups[i], (SUTransformation*)&t);
		visitFaces(ents2,func,true, transform * t);
	}

	if(recursive) {
		
		SUEntitiesGetNumInstances(ents,&count);
		vector<SUComponentInstanceRef> instances(count);
		SUEntitiesGetInstances(ents,count,instances.data(),&count);
	
		for(int i=0; i < count; i++){
			
			Transform t;
			SUComponentDefinitionRef def = SU_INVALID;
			SUEntitiesRef ents2 = SU_INVALID;

			SUComponentInstanceGetTransform(instances[i],(SUTransformation*)&t);
			SUComponentInstanceGetDefinition(instances[i],&def);
			SUComponentDefinitionGetEntities(def,&ents2);

			visitFaces(ents2,func,true, transform * t);
		}
	}
}

void ModelWriter::write(SUModelRef model)
{
	SUEntitiesRef ents = SU_INVALID;
	SUModelGetEntities(model,&ents);
	write(ents);
}

void ModelWriter::write(SUEntitiesRef ents, bool recursive)
{
	Transform baseTransform = {
		-1, 0, 0, 0,
		0, 0, 1, 0,
		0, 1, 0, 0,
		0, 0, 0, 1
	};

	cout << " - Gathering materials" << endl;
	visitFaces(ents, &ModelWriter::gatherMaterials, recursive);
	
	cout << " - Generating meshes" << endl;
	visitFaces(ents, &ModelWriter::makeHelper, recursive);
	
	cout << " - Writing Vertex data" << endl;
	visitFaces(ents, &ModelWriter::writeVertices, recursive);

	cout << " - Writing Faces" << endl;
	m_VerticesUsed = 1;
	m_TexCoordsUsed = 2;
	visitFaces(ents, &ModelWriter::writeFaces, recursive);

	
	cout << " - Writing Materials" << endl;
	for(set<void*>::iterator itr = m_Materials.begin(); itr != m_Materials.end(); itr++){
		SUMaterialRef mat = {*itr};
		m_MtlFile << "newmtl " <<  SketchupHelper::materialName(mat) << endl;
		
		m_MtlFile << "illium 4" << endl;

		SUColor ambient;
		SUMaterialGetColor(mat,&ambient);
		m_MtlFile << "Ka " << (ambient.red / 255.0f) << " " << (ambient.green/255.0f) << " " << (ambient.blue/255.0f) << endl; 
		m_MtlFile << "Kd " << (ambient.red / 255.0f) << " " << (ambient.green/255.0f) << " " << (ambient.blue/255.0f) << endl; 
				
		SUTextureRef tex = SU_INVALID;
		if(SUMaterialGetTexture(mat,&tex) == SU_ERROR_NONE) {
			SUStringRef fileName = SU_INVALID;
			SUStringCreate(&fileName);
			if(SUTextureGetFileName(tex,&fileName) == SU_ERROR_NONE) {
				string f = SketchupHelper::fromSUString(fileName);

				for(int i=0; i < f.length(); i ++){
					if(f[i] == ' ') f[i] = '_';
				}

				SUTextureWriteToFile(tex,(m_OutputDir+f).c_str());

				m_MtlFile << "Tf 1.00 1.00 1.00" << endl;
				//mtlFile << "map_Ka " << f << endl;
				m_MtlFile << "map_Kd " << f << endl;

				m_MtlFile << "Ni 1.00" << endl;
				m_MtlFile << "Ks 1.00 1.00 1.00" << endl;
				m_MtlFile << "Ns 0.00" << endl;
			}
		} 
	}
	
}

bool ModelWriter::shouldWriteBackFace(SUFaceRef face) {
	string name = SketchupHelper::getBackFaceMaterialName(face);
	if(name == "" || name == "$nodraw") {
		return false;
	}
	return true;
}

bool ModelWriter::shouldWriteFrontFace(SUFaceRef face) {
	string name = SketchupHelper::getFrontFaceMaterialName(face);
	if(name == "" || name == "$nodraw") {
		return false;
	}
	return true;
}

void ModelWriter::makeHelper(SUFaceRef face, const Transform&){

	SUMeshHelperRef helper = SU_INVALID;
	SUMeshHelperCreate(&helper,face);
	m_MeshHelpers[face.ptr] = helper;
}

void ModelWriter::gatherMaterials(SUFaceRef face, const Transform&){

	SUMaterialRef mat = SU_INVALID;
	
	if(shouldWriteFrontFace(face)) {
		SUFaceGetFrontMaterial(face, &mat);
		m_Materials.insert(mat.ptr);
	}

	if(shouldWriteBackFace(face)) {
		SUFaceGetBackMaterial(face, &mat);
		m_Materials.insert(mat.ptr);
	}
}

void ModelWriter::writeVertices(SUFaceRef face, const Transform& t){
	SUMeshHelperRef helper = m_MeshHelpers[face.ptr];

	//m_ObjFile << "# Verts for Face " << face.ptr << endl;

	size_t vertexCount = 0;
	SUMeshHelperGetNumVertices(helper,&vertexCount);
	
	vector<SUPoint3D> verts(vertexCount);
	vector<SUVector3D> normals(vertexCount);
	vector<SUPoint3D> tcs(vertexCount);

	SUMeshHelperGetVertices(helper,vertexCount,&verts[0],&vertexCount);
	SUMeshHelperGetNormals(helper,vertexCount,&normals[0],&vertexCount);

	if(shouldWriteFrontFace(face)) {

		bool textured = SketchupHelper::isFrontFaceTextured(face);

		if(textured) SUMeshHelperGetFrontSTQCoords(helper,vertexCount,&tcs[0],&vertexCount);

		for(size_t j=0; j < vertexCount; j++) {
			m_ObjFile << "v " << (verts[j] * t) / g_Scale << endl;
			
			if(textured) m_ObjFile << "vt " << tcs[j].x << " " << tcs[j].y << endl;
			m_ObjFile << "vn " << normals[j] * t << endl;
		}
	}

	if(shouldWriteBackFace(face)) {
		bool textured = SketchupHelper::isBackFaceTextured(face);
		if(textured) SUMeshHelperGetBackSTQCoords(helper,vertexCount,&tcs[0],&vertexCount);
		for(size_t j=0; j < vertexCount; j++) {
			m_ObjFile << "v " << (verts[j] * t) / g_Scale << endl;
			if(textured) m_ObjFile << "vt " << tcs[j].x << " " << tcs[j].y << endl;
			m_ObjFile << "vn " << normals[j]  * t << endl;
		}
	}
}

void ModelWriter::writeFaces(SUFaceRef face, const Transform&){
	SUMeshHelperRef mesh = m_MeshHelpers[face.ptr];

	size_t vertexCount=0;
	SUMeshHelperGetNumVertices(mesh,&vertexCount);

	size_t triCount = 0;
	SUMeshHelperGetNumTriangles(mesh,&triCount);

	size_t gotIndices = 0;
	vector<size_t> indicies(triCount*3);
	SUResult res = SUMeshHelperGetVertexIndices(mesh,triCount*3,indicies.data(),&gotIndices);
	assert(res == SU_ERROR_NONE);
		
	
	if(shouldWriteFrontFace(face)) {
	
	//	m_ObjFile << "# Front  Face " << face.ptr << endl;
		
		string mat = SketchupHelper::getFrontFaceMaterialName(face);
		if(mat != m_CurrentMat){
			m_CurrentMat = mat;
			m_ObjFile << "usemtl " << mat << endl;
		}
		size_t s = m_VerticesUsed;
		
		if(SketchupHelper::isFrontFaceTextured(face)) {
			size_t t = m_TexCoordsUsed;
			for(size_t j=0; j < triCount; j++) {
				m_ObjFile << "f ";
				m_ObjFile << (s + indicies[(j*3)+0]) << "/" << (t + indicies[(j*3)+0]) << "/" << (s + indicies[(j*3)+0])<< " ";
				m_ObjFile << (s + indicies[(j*3)+1]) << "/" << (t + indicies[(j*3)+1]) << "/" << (s + indicies[(j*3)+1]) << " ";
				m_ObjFile << (s + indicies[(j*3)+2]) << "/" << (t + indicies[(j*3)+2]) << "/" << (s + indicies[(j*3)+2]) << endl;
			}
			m_TexCoordsUsed += vertexCount;
		}else {
			for(size_t j=0; j < triCount; j++) {
		
				m_ObjFile << "f ";
				m_ObjFile << (s + indicies[(j*3)+0]) << "/1/" << (s + indicies[(j*3)+0])<< " ";
				m_ObjFile << (s + indicies[(j*3)+1]) << "/1/" << (s + indicies[(j*3)+1]) << " ";
				m_ObjFile << (s + indicies[(j*3)+2]) << "/1/" << (s + indicies[(j*3)+2]) << endl;
			}	
		}
			
		m_VerticesUsed += vertexCount;
	}

	if(shouldWriteBackFace(face)) {
	
		m_ObjFile << "# Back Face " << face.ptr << endl;
		m_ObjFile << "usemtl " << SketchupHelper::getBackFaceMaterialName(face) << endl;

		size_t s = m_VerticesUsed;
		
		if(SketchupHelper::isBackFaceTextured(face)) {
			size_t t = m_TexCoordsUsed;
			for(size_t j=0; j < triCount; j++) {
				m_ObjFile << "f ";
				m_ObjFile << (s + indicies[(j*3)+2]) << "/" << (t + indicies[(j*3)+2]) << "/" << (s + indicies[(j*3)+2]) << " ";
				m_ObjFile << (s + indicies[(j*3)+1]) << "/" << (t + indicies[(j*3)+1]) << "/" << (s + indicies[(j*3)+1]) << " ";
				m_ObjFile << (s + indicies[(j*3)+0]) << "/" << (t + indicies[(j*3)+0]) << "/" << (s + indicies[(j*3)+0]) << endl;
			}
			m_TexCoordsUsed += vertexCount;
		} else {
			for(size_t j=0; j < triCount; j++) {
				m_ObjFile << "f ";
				m_ObjFile << (s + indicies[(j*3)+2]) << "/1/" << (s + indicies[(j*3)+2]) << " ";
				m_ObjFile << (s + indicies[(j*3)+1]) << "/1/" << (s + indicies[(j*3)+1]) << " ";
				m_ObjFile << (s + indicies[(j*3)+0]) << "/1/" << (s + indicies[(j*3)+0]) << endl;
			}
		}
		
		m_VerticesUsed += vertexCount;
	}
}


void ModelWriter::exportComponents(SUModelRef model, const string& dir, bool overwrite) {
	cout << "Exporting components from model" << endl;

	SUEntitiesRef ents = SU_INVALID;
	SUModelGetEntities(model,&ents);

	// Get the entity container of the model
	size_t numInstances =0;
	SUEntitiesGetNumInstances(ents,&numInstances);

	vector<SUComponentInstanceRef> instances(numInstances);
	SUEntitiesGetInstances(ents,numInstances,instances.data(),&numInstances);

	map<string,bool> foundComponents;

	for(size_t i=0; i < numInstances; i++) {

		string type = SketchupHelper::componentInstanceType(instances[i]);;

		if(type[0] == '!') {
			continue;
		}

		if(foundComponents[type] == false) {

			if(fileExists(dir + type + ".obj") && !overwrite) {

				cout << "File " << type << ".obj exists, skipping..." << endl;

			} else {
			
				SUComponentDefinitionRef component = SU_INVALID;
				SUComponentInstanceGetDefinition(instances[i],&component);

				SUEntitiesRef entities = SU_INVALID;
				SUComponentDefinitionGetEntities(component,&entities);

				cout << "Writing component " << type << endl;
				ModelWriter writer(dir,type);
				writer.write(entities,true);

			}

			foundComponents[type] = true;
		}
	}

	cout << "Done exporting components" << endl;
}