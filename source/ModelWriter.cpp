#include "StdAfx.h"
#include "ModelWriter.h"
#include "SketchupHelper.h"
#include "Material.h"


ModelWriter::ModelWriter(const string& dir, const string& name)
{
	m_OutputDir = dir;

	m_ObjFile.open(m_OutputDir + name + ".obj");
	m_ObjFile << "# File generated by sketchup2room" << endl;
	m_ObjFile << "mtllib " << name << ".mtl" << endl;
	m_ObjFile.precision(3);
	m_ObjFile.setf( std::ios::fixed, std:: ios::floatfield );

	m_Faces.precision(3);
	m_Faces.setf( std::ios::fixed, std:: ios::floatfield );

	m_MtlFile.open(m_OutputDir + name + ".mtl");
	m_MtlFile << "# File generated by sketchup2room" << endl;

}


ModelWriter::~ModelWriter(void)
{
}


void ModelWriter::visitFaces(SUEntitiesRef ents, VisitorFunc func, bool recursive, Transform transform)
{
	size_t count =0;
	SUEntitiesGetNumFaces(ents,&count);

	vector<SUFaceRef> faces(count);
	SUEntitiesGetFaces(ents,count,faces.data(),&count);

	for(int i=0; i < count; i++){
		(*this.*func)(faces[i], transform);
	}

	SUEntitiesGetNumGroups(ents,&count);
	vector<SUGroupRef> groups(count);
	SUEntitiesGetGroups(ents,count,groups.data(),&count);


	for(int i=0; i < count; i++){
		SUEntitiesRef ents2 = SU_INVALID;
		SUGroupGetEntities(groups[i],&ents2);

		Transform t;
		SUGroupGetTransform(groups[i], (SUTransformation*)&t);
		visitFaces(ents2,func,true, transform * t);
	}

	if(recursive) {
		
		SUEntitiesGetNumInstances(ents,&count);
		vector<SUComponentInstanceRef> instances(count);
		SUEntitiesGetInstances(ents,count,instances.data(),&count);
	
		for(int i=0; i < count; i++){
			
			Transform t;
			SUComponentDefinitionRef def = SU_INVALID;
			SUEntitiesRef ents2 = SU_INVALID;

			SUComponentInstanceGetTransform(instances[i],(SUTransformation*)&t);
			SUComponentInstanceGetDefinition(instances[i],&def);
			SUComponentDefinitionGetEntities(def,&ents2);

			visitFaces(ents2,func,true, transform * t);
		}
	}
}

void ModelWriter::write(SUEntitiesRef ents, bool recursive)
{
	cout << " - Gathering materials" << endl;
	visitFaces(ents, &ModelWriter::gatherMaterials, recursive);
	

	for(map<string,SUMaterialRef>::iterator itr = m_Materials.begin(); itr != m_Materials.end(); itr++) {
		cout << " - Writing faces of " << itr->first << endl;

		Material mat(itr->second);
		mat.saveTextures(m_OutputDir);

		m_MtlFile << mat << endl;

		m_CurrentMat = mat.fullName;
		m_Faces << "usemtl " << mat.name << endl;
		visitFaces(ents, &ModelWriter::writeFaces, recursive);
	}

	for(size_t i = 0; i < m_UniquePositions.size(); i++) 
		m_ObjFile << "v " << m_UniquePositions[i] / g_Scale << endl;

	for(size_t i = 0; i < m_UniqueNormals.size(); i++) 
		m_ObjFile << "vn " << m_UniqueNormals[i] / g_Scale << endl;

	for(size_t i = 0; i < m_UniqueTextures.size(); i++) 
		m_ObjFile << "vt " << m_UniqueTextures[i].x << " " << m_UniqueTextures[i].y << endl;


	m_ObjFile << m_Faces.str();
		
}

bool ModelWriter::shouldWriteBackFace(SUFaceRef face) {
	string name = SketchupHelper::getBackFaceMaterialName(face);
	if(name == "" || name == "$nodraw") {
		return false;
	}
	return true;
}

bool ModelWriter::shouldWriteFrontFace(SUFaceRef face) {
	string name = SketchupHelper::getFrontFaceMaterialName(face);
	if(name == "" || name == "$nodraw") {
		return false;
	}
	return true;
}



void ModelWriter::gatherMaterials(SUFaceRef face, const Transform&){

	SUMaterialRef mat = SU_INVALID;
	
	if(shouldWriteFrontFace(face)) {
		SUFaceGetFrontMaterial(face, &mat);
		m_Materials[SketchupHelper::materialName(mat)] = mat;
	}

	if(shouldWriteBackFace(face)) {
		SUFaceGetBackMaterial(face, &mat);
		m_Materials[SketchupHelper::materialName(mat)] = mat;
	}
}


void ModelWriter::writeFace(SUMeshHelperRef mesh, const Transform& transform, bool front, bool textured) {

	size_t vertexCount=0;
	SUMeshHelperGetNumVertices(mesh,&vertexCount);
	vector<SUPoint3D> verts(vertexCount);
	SUMeshHelperGetVertices(mesh,vertexCount,verts.data(),&vertexCount);

	vector<SUVector3D> normals(vertexCount);
	SUMeshHelperGetNormals(mesh,vertexCount,normals.data(),&vertexCount);

	vector<SUPoint3D> textures(vertexCount);
	
	size_t triCount = 0;
	SUMeshHelperGetNumTriangles(mesh,&triCount);

	size_t gotIndices = 0;
	vector<size_t> indicies(triCount*3);
	SUResult res = SUMeshHelperGetVertexIndices(mesh,triCount*3,indicies.data(),&gotIndices);
	assert(res == SU_ERROR_NONE);

	if(textured) {
		if(front) {
			SUMeshHelperGetFrontSTQCoords(mesh,vertexCount,textures.data(),&vertexCount);
		} else {
			SUMeshHelperGetBackSTQCoords(mesh,vertexCount,textures.data(),&vertexCount);
		}
	}
	float normalScale = 1.0f;
	if(!front) {
		normalScale = -1.0f;
	}
	
	bool flip = !front;

	SUVector3D xFlipTest = xaxis * transform;
	if(xFlipTest.x < 0) {
		flip = !flip;
	}

	SUVector3D yFlipTest = yaxis * transform;
	if(yFlipTest.y < 0) {
		flip = !flip;
	}
	
	for(size_t t = 0; t < triCount; t++) {
			
		m_Faces << "f ";

		for(int i=0; i<3; i++) {

			int j = (t*3) + (flip ? 2-i : i);
			
			m_Faces << getIndexedPos(verts[indicies[j]]*transform) << "/";
			
			if(textured)
				m_Faces << getIndexedTex(textures[indicies[j]]);
			
			m_Faces << "/" <<  getIndexedNormal(normals[indicies[j]]*normalScale*transform) << " ";
		}

		m_Faces << endl;
	}

}

void ModelWriter::writeFaces(SUFaceRef face, const Transform& t){

	SUMeshHelperRef mesh = SU_INVALID;
	SUMeshHelperCreate(&mesh,face);

	if(SketchupHelper::getFrontFaceMaterialName(face) == m_CurrentMat) {
		writeFace(mesh, t, true, SketchupHelper::isFrontFaceTextured(face));
	}

	if(SketchupHelper::getBackFaceMaterialName(face) == m_CurrentMat) {
		writeFace(mesh, t, false, SketchupHelper::isBackFaceTextured(face));
	}
	
}


string ModelWriter::getMaterialFile(const string& objFile) {

	ifstream file(objFile);

	if(!file.good()) {
		cerr << "Error examining file " << objFile;
		exit(1);
	}

	char buffer[400];
	while(!file.eof()) {

		file.getline(buffer,sizeof(buffer));

		if(strncmp(buffer,"mtllib",6) == 0){
			string file = buffer+7;
			if(file[0] == '.' && file[1] == '/')
				file = file.substr(2);

			return dirName(objFile) + file;
		}
	}

	return "";
}

set<string> ModelWriter::getTextures(const string& mtlFile) {

	set<string> ret;
	ifstream file(mtlFile);


	char buffer[300];
	while(!file.eof()) {

		file.getline(buffer,sizeof(buffer));

		if(strncmp(buffer,"map_Kd",6) == 0){
			string file = buffer+7;
			if(file[0] == '.' && file[1] == '/')
				file = file.substr(2);

			ret.insert(dirName(mtlFile) + file);
		}
	}

	return ret;
}